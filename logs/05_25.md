### 2025-05-02

First day using the OrangePi! Time to port over all the code.

First, the compilation. Since it is armv7, I assume it is arm-none-eabi? I am
not sure.

I want to learn a bit about ELF, EABI, etc.

## ELF

The Executable and Linkable Format is used to store binaries such as object
files, core dumps, libraries, and executables. It is designed to be flexible,
cross-platform, and extensible. Different architectures, endianess... Anything
binary works for ELF.

The content of the ELF header includes the following.

* Program header table - describes memory segments like data and text
* Section header table - describes sections
* Data - contains data of the above

*Data* has to do with runtime execution, and *section* has to do with linking
and relocation.

## EABI

First, let's discuss what an Application Binary Interface (ABI) is. It
is essentially the ISA plus the operating system abstractions. It is the
interface upon which application binaries operate.

An embedded ABI (EABI) specifies aspects such as file formats, data types,
register usage, stack frame organization, and function parameter passing of an
embedded software program. This seem somewhat random?

* File formats makes sense: It is what the rest is built on
* Data types... what is that used for? Debugging?

Wait, it governs calling conventions, stack usage, register allocation, etc.
This is not done by ELF. EABI is not just a specification on how to store object
code; it also specifies what the object code actually is!

## Flashing Orangepi

In the schematics, UBoot is pulled up.


## NEVERMIND

I have come to the conclusion that an affordable, open system does not exist. As
such, I will revert back to my first method: reverse engineering Raspberry Pi.

First, I need to make sure I can flash with SD card.

Why is the offset 0x80000? Linux kernel seem to have something to do with it.
Let's take a look at how the linux kernel works with raspberry pi.

Raspberry pi supports linux kernels. As such, if I simply have an image that
conforms to the Linux kernel, I can run my program.


#### Device tree

I have  made a breakthrough! One of the ways for the Linux kernel to understand
the hardware is the *device tree*. It contains useful information such as the
location of the peripherals. This would be very helpful in reverse engineering
the BCM 2711 SOC.

[This video](https://youtu.be/Nz6aBffv-Ek?si=4FHMvRuZim8A0VQm) is instrumental
in helping me discover this.


#### 0x80000, the first instruction

This information is obtained from
[Deepseek](https://chat.deepseek.com/a/chat/s/3183adda-765f-4b7c-b58e-1f0330bb42f9)
and [Linux docs](https://www.kernel.org/doc/html/latest/arch/arm64/booting.html)

Upon booting the raspberry pi, the proprietary bootloader within would first
look at the image header. The first few instructions is literally just branching
to the entry code (makes sense). The following entries have some metadata. The
one most relevant to me is `text_offset`, which specifies where the image must
be loaded!

Do I need to make this header? I don't see the tutorial doing it, so for now I
will assume that Raspberry Pi 4B assumes that text_offset is 0x80000.

My immediate goal is to use -sd to pass the image.
